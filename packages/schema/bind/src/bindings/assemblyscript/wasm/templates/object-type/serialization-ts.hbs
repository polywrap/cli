{{> serialization_imports}}
import { {{detectKeyword name}} } from "./";
import * as Types from "..";

export function serialize{{name}}(type: {{detectKeyword name}}): ArrayBuffer {
  const sizerContext: Context = new Context("Serializing (sizing) object-type: {{name}}");
  const sizer = new WriteSizer(sizerContext);
  write{{name}}(sizer, type);
  const buffer = new ArrayBuffer(sizer.length);
  const encoderContext: Context = new Context("Serializing (encoding) object-type: {{name}}");
  const encoder = new WriteEncoder(buffer, sizer, encoderContext);
  write{{name}}(encoder, type);
  return buffer;
}

export function write{{name}}(writer: Write, type: {{detectKeyword name}}): void {
  {{#if props.length}}
  writer.writeMapLength({{props.length}});
  {{else}}
  writer.writeMapLength(0);
  {{/if}}
  {{#each props}}
  writer.context().push("{{name}}", "{{toWasm type}}", "writing property");
  writer.writeString("{{name}}");
  {{#if (eq type.kind "Scalar") }}
  writer.write{{toMsgPack type}}(type.{{detectKeyword name}});
  {{/if}}
  {{#if (eq type.kind "Array") }}
  writer.write{{toMsgPack type}}(type.{{detectKeyword name}}, (writer: Write, item: {{toWasm type.item}}): void => {
    {{> serialize_array}}
  });
  {{/if}}
  {{#if (eq type.kind "Map") }}
  writer.write{{toMsgPack type}}(type.{{detectKeyword name}}, (writer: Write, key: {{toWasm type.key}}) => {
    writer.write{{toMsgPack type.key}}(key);
  }, (writer: Write, value: {{toWasm type.value}}): void => {
    {{> serialize_map_value}}
  });
  {{/if}}
  {{#if (eq type.kind "Ref")}}
    {{#if (eq type.ref_kind "Object") }}
      {{#if required}}
      Types.{{detectKeyword name}}.write(writer, type.{{detectKeyword name}});
      {{else}}
      if (type.{{detectKeyword name}}) {
        Types.{{detectKeyword name}}.write(writer, type.{{detectKeyword name}} as Types.{{detectKeyword name}});
      } else {
        writer.writeNil();
      }
      {{/if}}
    {{/if}}
    {{#if (eq type.ref_kind "Enum") }}
      {{#if required}}
      writer.writeInt32(type.{{detectKeyword name}});
      {{else}}
      writer.writeOptionalInt32(type.{{detectKeyword name}});
      {{/if}}
    {{/if}}
  {{/if}}
  writer.context().pop();
  {{/each}}
}

export function deserialize{{name}}(buffer: ArrayBuffer): {{detectKeyword name}} {
  const context: Context = new Context("Deserializing object-type {{name}}");
  const reader = new ReadDecoder(buffer, context);
  return read{{name}}(reader);
}

export function read{{name}}(reader: Read): {{detectKeyword name}} {
  let numFields = reader.readMapLength();

  {{#each props}}
  {{#if (eq object)}}
    {{#if (eq required)}}
    let _{{name}}: {{toWasm type}} | null = null;
    {{else}}
    let _{{name}}: {{toWasm type}} = {{toWasmInit type}};
    {{/if}}
  {{else}}
  let _{{name}}: {{toWasm type}} = {{toWasmInit type}};
  {{/if}}
  {{#if required}}
  let _{{name}}Set: bool = false;
  {{/if}}
  {{/each}}

  while (numFields > 0) {
    numFields--;
    const field = reader.readString();

    reader.context().push(field, "unknown", "searching for property type");
    {{#each props}}
    {{^first}}else {{/first}}if (field == "{{name}}") {
      reader.context().push(field, "{{toWasm type}}", "type found, reading property");
      {{#scalar}}
      _{{name}} = reader.read{{#toMsgPack}}{{toGraphQLType}}{{/toMsgPack}}();
      {{/scalar}}
      {{#array}}
      _{{name}} = reader.read{{#toMsgPack}}{{toGraphQLType}}{{/toMsgPack}}((reader: Read): {{#item}}{{toWasm item}}{{/item}} => {
        {{> deserialize_array}}
      });
      {{/array}}
      {{#map}}
      _{{name}} = reader.read{{#toMsgPack}}{{toGraphQLType}}{{/toMsgPack}}((reader: Read): {{#key}}{{toWasm item}}{{/key}} => {
        return reader.read{{#key}}{{#toMsgPack}}{{toGraphQLType}}{{/toMsgPack}}{{/key}}();
      }, (reader: Read): {{#value}}{{toWasm item}}{{/value}} => {
        {{> deserialize_map_value}}
      });
      {{/map}}
      {{#enum}}
      {{> deserialize_enum}}
      _{{name}} = value;
      {{/enum}}
      {{#object}}
      {{> deserialize_object }}
      _{{name}} = object;
      {{/object}}
      {{#required}}
      _{{name}}Set = true;
      {{/required}}
      reader.context().pop();
    }
    {{/each}}
    reader.context().pop();
  }

  {{#each props}}
  {{#if (eq required)}}
  {{^object}}
  if (!_{{name}}Set) {
  {{/object}}
  {{#object}}
  if (!_{{name}} || !_{{name}}Set) {
  {{/object}}
    throw new Error(reader.context().printWithContext("Missing required property: '{{name}}: {{name}}'"));
  }
  {{/required}}
  {{/each}}

  return {
    {{#props}}
    {{detectKeyword name}}: _{{name}}{{^last}},{{/last}}
    {{/props}}
  };
}
